//题目概述：有个蠢人走进了一个n*m的迷宫，迷宫有障碍，先输入n和m，之后的n行输入障碍位置其中’#‘表示障碍，’.‘表示空地可以走，让你判断能否走出，可输出yes，否则输出no;
//核心思路：这种迷宫问题，遍历数，图等问题适合用广度搜索（BFS)，核心实现方法就是队列queue先从起始点开始，放入队列中，然后本题由于是走迷宫所以每一步都可以选择上下左右移动，从而一层一层遍历看看是否可以走过去，每次遍历下一层是都要弹出上一层的队头，存入下一层的位置就这样到最后看看能不能到达（n,m)的位置，即终点。
#include<bits/stdc++.h>
using namespace std;
struct node{//这里定义的结构体实际上就是一个坐标数据类型这种方式更方便，存入队列简单
    int x,y;
};
queue<node>q;//创建核心实现场所，队列；
int n,m;//题目要求的n*m的迷宫
char s[101][101];//这个是用来存储迷宫布局的，即哪个点是障碍，哪个点是空地，因为这里要求的是字符表示所以是char；
int dx[4]={-1,0,1,0};//下面两行表示的是方向，每次到达一个坐标后看看向这四个方向走，看看行不行，行就继续下一个位置遍历；你可能会问为什么这里也不像上面那样直接定义node型，答案是可以的，但写出来看起来太复杂了
int dy[4]={0,1,0,-1};
bool bfs(int x,int y){//这个函数就是BFS实现的核心代码；
    int a,b;//a,b表示的是进入到新的位置后这个点此时的横纵坐标;
    s[x][y]='#';//先把起始点出标记为#，意义是不能走回头路了；
    q.push({x,y});//将这个起始点传入队头，开始一层一层遍历，也就是一步一步开始走；
    while(!q.empty()){//为空返回的是true，这里判断的应该是不为空才执行，所以要加一个  ！注意中英符号，为什么一定要判断是不是空，如果为空的话，怎么进行通过本来该存入这里的点来检索与他相关的点呢，意思就是本来这里应该放的是你此时的位置，没有他你怎么能知道往哪走呢，你都没走到这怎么接着往下走呢？
        auto u=q.front(); q.pop();//记下这个点也就是当前位置然后弹出，弹出是因为你要接着走啊，每次队列的队头都是你当前位置，所以这里要弹出，记下是因为你要接着走需要现在位置为基础往下走；
        for(int i=0;i<4;i++){//四个方向都遍历判断可不可走；
            a=u.x+dx[i];//坐标的相加减；
            b=u.y+dy[i];
            if(a<1||a>n||b<1||b>m) continue;//这里的起始点是1，1所以1，1等效于原来的0，0所以是小于1，而且这个迷宫是n*m切记！！！  走出了迷宫范围肯定不行啊所以忽略这个方向，换一个方向；
            if(a==n&&b==m) return 1;//表示走到了终点
            if(s[a][b]=='#')continue;//注意这个双等啊，好几次都忘了，这种情况别忘记，前面遍历过后，下次再次便利就不会入队，或者本身就是障碍不能过去，跳过进行下次循环，即走过的路不会走而是向其他方向走；
            s[a][b]='#';//走过后一定要标记为#表示不走回头路；
            q.push({a,b});//将可走的位置放入队列中，进行遍历与其相关的点；
        }
    }
    return 0;
}
int main(){
    cin>>n>>m;
  for(int i=1;i<=n;i++)
    scanf("%s",s[i]+1);//这里很有趣是s[i]表示第i行的0号元素后面+1就表示向右移动，每次都移动，就代替了双层for循环的效果；
    if(bfs(1,1)) cout<<"Yes";
    else cout<<"No";
}
