#include<bits/stdc++.h>
using namespace std;
int a[5005][5005];//用来预留出一个前缀和数组，直接复用
int main(){
    int m,n,vi,xi,yi;//地图上有n个目标，炸弹可以摧毁边长为m的正方形内的所有目标除了边长，vi为其价值
    cin>>n>>m;
    while(n--){
        cin>>xi>>yi>>vi;//每次输入一个目标坐标及其价值
        xi++,yi++;//为了是让下标从1开始，是前缀和操作更简单，防止超出数组边界范围
        a[xi][yi]+=vi;
    }
    for(int i=1;i<=5001;i++){
        for(int j=1;j<=5001;j++){
            a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
            //进行前缀和操作，从一开始防止超出范围，原理基于容斥
        }
    }
    int res=0;//由于本题要求得出最大价值，所以要进行max比较这里将答案先设为0，以便之后循环枚举的比较
    for(int i=m;i<=5001;i++){
        for(int j=m;j<=5001;j++){
            res=max(res,a[i][j]-a[i][j-m]-a[i-m][j]+a[i-m][j-m]);
            //这里注意坐标题目给出的最大也是5000，偏移后最大5001，5005则会超过数组范围会re，5002之类的由于上面对于预留出的前缀和数组只到5001所以在这里循环到5002时是错误的前缀和所以不行，答案可能出错，只有前缀和正确才可以，而且数组太大建议开全局
            //求出边长为m的正方形内价值和，原理也为容斥，减去上左的前缀和再补上重复减去的，最后就是这个区域内的和
            //枚举是枚举的正方形右下角的点先是m，m即为左上部分，在向右平移一直到数组边界，然后在将行下移一位，再重复向右
        }
    }
    cout<<res;

}