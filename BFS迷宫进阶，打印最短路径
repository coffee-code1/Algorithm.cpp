//题目不变与上一个一样，只不过障碍变成了’1‘代表，输出最短的路径，输出要求输出每一步的坐标；
#include<bits/stdc++.h>
using namespace std;
int arr[1010][1010];
int n;
struct node{int x,y;}path[1010][1010];//这里为什么开的是一个node型的二维数组而不是int类型的二维数组呢，int型的二维数组乍一看也是坐标但他存储的只是一个值不是坐标,之所以是二维数组形式是为了下面每到一个可走点来存储上一个来时点位置用的，一个坐标位置对应上一个坐标位置；
queue<node>q;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
void bfs(int x,int y){
    arr[x][y]=1;
    q.push({x,y});//x,y表示的就是坐标，而这个点对应的数组元素表示能不能走；说是最短路径，实际上哪条路先行遍历完就表示这条路最短；
    while(!q.empty()){
        auto u=q.front(); q.pop();
        for(int i=0;i<4;i++){
            int a=u.x+dx[i];
            int b=u.y+dy[i];
            if(a<0||a>=n||b<0||b>=n) continue;
            if(arr[a][b]==1) continue;//1表示走过或者障碍;双等！！
            arr[a][b]=1;
            q.push({a,b});
            path[a][b]=u;//当前可走位置存储的是上一个可走位置这样存储下来，就形成了走过的来时路；
        }
    }
}
void print(int x,int y){
    if(x==0&&y==0) return;//很巧妙,由于我正这进行bfs所以这里要进行一次颠倒顺序才能从起点输出到终点;
    auto p=path[x][y];//记录上个点;
    print(p.x,p.y);//这里就用到递归了,一直递归从终点一路到起点,这时就触发了上面的if从而return,return会使上一次递归进行下面的输出所以就会输出起点的下一个位置点,以此类推这样顺序就正确了,但这样会发现起点没输出得手动加;
    printf("%d %d ->",p.x,p.y);
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        scanf("%d%d",arr[i]+1);//1表示障碍，0表示可走；两个%d哦因为是两个数；
    }
    //第一种搜索打印方式;
    bfs(n-1,n-1);//到这搜索，从终点搜到起点，为了下面打印路线方便，如果从起点搜也可以但需要先反转一下path的顺序，因为打印路径是从起点开始的，而path是由后一个点得出前一个点;
    node p={0,0};
    while(1){
        printf("%d %d ->/n",p.x,p.y);
        if(p.x==n-1&&p.y==n-1) break;//一定要放在上面，否则会少打印一个点；因为n-1的时候上面打印过了，这个时候就是边界了所以退出循环，如果是n的话那么n-1的时候就会使得下面path进行访问越界；
        p=path[p.x][p.y];//这里就是通过这个当前位置找到下一个点，进行赋值，因为是倒着bfs的所以存储的上一个位置也就变成了正的了；
        
    }
    //第二种搜扫打印方式;
    //bfs(0,0);
    //puts("0 0 ->");这也是个输出函数,会自动换行输出完后,也要引号;
    //print(n-1,n-1);第二种输出方案这里对应的时正着bfs;
}
